$OpenBSD: patch-get_iplayer,v 1.57 2013/09/29 22:57:57 sthen Exp $
--- get_iplayer.orig	Sun Sep 29 23:41:40 2013
+++ get_iplayer	Sun Sep 29 23:41:32 2013
@@ -136,8 +136,10 @@ my $opt_format = {
 	stop		=> [ 1, "stop=s", 'Recording', '--stop <secs|hh:mm:ss>', "Recording/streaming stop offset (can be used to limit live rtmp recording length) rtmp and realaudio only"],
 	suboffset	=> [ 1, "suboffset=n", 'Recording', '--suboffset <offset>', "Offset the subtitle timestamps by the specified number of milliseconds"],
 	subtitles	=> [ 2, "subtitles|subs!", 'Recording', '--subtitles', "Download subtitles into srt/SubRip format if available and supported"],
+	subsfmt		=> [ 1, "subsfmt=s", 'Search', '--subsfmt <format>', "Subtitles format.  One of: default, compact.  Default: 'default'"],
 	subsonly	=> [ 1, "subtitlesonly|subsonly|subtitles-only|subs-only!", 'Recording', '--subtitles-only', "Only download the subtitles, not the programme"],
 	subsraw		=> [ 1, "subsraw!", 'Recording', '--subsraw', "Additionally save the raw subtitles file"],
+	subsrequired		=> [ 1, "subsrequired|subs-required|subtitles-required!", 'Recording', '--subtitles-required', "Do not download TV programme if subtitles are not available."],
 	tagonly		=> [ 1, "tagonly|tag-only!", 'Recording', '--tag-only', "Only update the programme tag and not download the programme (can also be used with --history)"],
 	test		=> [ 1, "test|t!", 'Recording', '--test, -t', "Test only - no recording (will show programme type)"],
 	thumb		=> [ 1, "thumb|thumbnail!", 'Recording', '--thumb', "Download Thumbnail image if available"],
@@ -153,7 +155,7 @@ my $opt_format = {
 	excludecategory	=> [ 0, "xcat|exclude-category=s", 'Search', '--exclude-category <string>', "Narrow search to exclude matched categories (regex or comma separated values)"],
 	excludechannel	=> [ 0, "xchan|exclude-channel=s", 'Search', '--exclude-channel <string>', "Narrow search to exclude matched channel(s) (regex or comma separated values)"],
 	fields		=> [ 0, "fields=s", 'Search', '--fields <field1>,<field2>,..', "Searches only in the specified comma separated fields"],
-	future		=> [ 1, "future!", 'Search', '--future', "Search future programme schedule if it has been indexed (refresh cache with: --refresh --refresh-future)."],
+	future		=> [ 1, "future!", 'Search', '--future', "Additionally search future programme schedule if it has been indexed (refresh cache with: --refresh --refresh-future)."],
 	long		=> [ 0, "long|l!", 'Search', '--long, -l', "Additionally search in programme descriptions and episode names (same as --fields=name,episode,desc )"],
 	search		=> [ 1, "search=s", 'Search', '--search <search term>', "GetOpt compliant way of specifying search args"],
 	history		=> [ 1, "history!", 'Search', '--history', "Search/show recordings history"],
@@ -318,6 +320,7 @@ $opt->{verbose} = 1 if $opt_pre->{verbose};
 $opt->{quiet} = 1 if $opt_pre->{quiet};
 $opt->{pvr} = 1 if $opt_pre->{pvr};
 $opt->{stdout} = 1 if $opt_pre->{stdout} || $opt_pre->{stream};
+$opt->{packagemanager}= 'pkg_add';
 
 # show version and exit
 if ( $opt_pre->{showver} ) {
@@ -358,7 +361,7 @@ my $plugin_dir_system;
 if ( defined $ENV{ALLUSERSPROFILE} ) {
     $plugin_dir_system = $ENV{ALLUSERSPROFILE}.'/get_iplayer/plugins';
 } else {
-    $plugin_dir_system = '/usr/share/get_iplayer/plugins';
+    $plugin_dir_system = '${TRUEPREFIX}/share/get_iplayer/plugins';
 }
 my $plugin_dir_user = "$profile_dir/plugins";
 for my $plugin_dir ( ( $plugin_dir_user, $plugin_dir_system ) ) {
@@ -771,7 +774,7 @@ sub init_search {
 	delete $binopts->{vlc};
 	push @{ $binopts->{vlc} }, '-vv' if $opt->{debug};
 
-	$bin->{id3v2}		= $opt->{id3v2} || 'id3v2';
+	$bin->{id3v2}		= $opt->{id3v2} || 'id3tag';
 	$bin->{atomicparsley}	= $opt->{atomicparsley} || 'AtomicParsley';
 
 	$bin->{tee}		= 'tee';
@@ -1426,14 +1429,16 @@ sub user_agent {
 		update		=> [ "get_iplayer updater (v${version} - $^O - $^V)" ],
 		get_iplayer	=> [ "get_iplayer/$version $^O/$^V" ],
 		desktop		=> [
-				'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; .NET CLR 2.0.50<RAND>; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30<RAND>; InfoPath.1)',
-				'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; YPC 3.2.0; SLCC1; .NET CLR 2.0.50<RAND>; .NET CLR 3.0.04<RAND>)',
-				'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50<RAND>; .NET CLR 3.5.30<RAND>; .NET CLR 3.0.30<RAND>; Media Center PC 6.0; InfoPath.2; MS-RTC LM 8)',
-				'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/<RAND>.8 (KHTML, like Gecko) Chrome/2.0.178.0 Safari/<RAND>.8',
-				'Mozilla/5.0 (compatible; MSIE 7.0; Windows NT 6.0; SLCC1; .NET CLR 2.0.50<RAND>; Media Center PC 5.0; c .NET CLR 3.0.0<RAND>6; .NET CLR 3.5.30<RAND>; InfoPath.1; el-GR)',
-				'Mozilla/5.0 (Macintosh; U; PPC Mac OS X 10_4_11; tr) AppleWebKit/<RAND>.4+ (KHTML, like Gecko) Version/4.0dp1 Safari/<RAND>.11.2',
-				'Mozilla/6.0 (Windows; U; Windows NT 7.0; en-US; rv:1.9.0.8) Gecko/2009032609 Firefox/3.0.9 (.NET CLR 3.5.30<RAND>)',
-				'Opera/9.64 (X11; Linux i686; U; en) Presto/2.1.1',
+				'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.17 (KHTML, like Gecko) Chrome/24.0.1312.56 Safari/537.17',
+				'Mozilla/5.0 (Windows NT 6.1; rv:12.0) Gecko/20100101 Firefox/12.0',
+				'Opera/9.80 (Windows NT 5.1) Presto/2.12.388 Version/12.12',
+				'Mozilla/5.0 (Windows NT 7.1; rv:2.0) Gecko/20100101 Firefox/4.0 Opera 12.12',
+				'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.0) Opera 12.12',
+				'Mozilla/5.0 (Windows NT 5.1; rv:18.0) Gecko/20100101 Firefox/18.0',
+				'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/537.13+ (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2',
+				'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident/6.0)',
+				'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 7.1; Trident/5.0)',
+				'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)',
 				],
 		safari		=> [
 				'Mozilla/5.0 (iPhone; U; CPU iPhone OS 2_0 like Mac OS X; en-us) AppleWebKit/525.18.1 (KHTML, like Gecko) Version/3.1.1 Mobile/5A345 Safari/525.20',
@@ -2730,7 +2735,14 @@ sub run_cmd {
 	my $USE_SYSTEM = 0;
 	#my $system_suffix;
 
-	main::logger "\n\nINFO: Command: ".(join ' ', map {s/\"/\\\"/g; "\"$_\"";} @cmd)."\n\n" if $opt->{verbose};
+	my $log_str;
+	my @log_cmd = @cmd;
+	if ( $#log_cmd > 0 ) {
+		$log_str = (join ' ', map {s/\"/\\\"/g; "\"$_\"";} @log_cmd)
+	} else {
+		$log_str = $log_cmd[0]
+	}
+	main::logger "\n\nINFO: Command: $log_str\n\n" if $opt->{verbose};
 
 	# Define what to do with STDOUT and STDERR of the child process
 	my $fh_child_out = ">&STDOUT";
@@ -4018,7 +4030,11 @@ sub create_dir {
 	my $prog = shift;
 	if ( (! -d "$prog->{dir}") && (! $opt->{test}) ) {
 		main::logger "INFO: Creating dir '$prog->{dir}'\n" if $opt->{verbose};
-		mkpath("$prog->{dir}");
+		eval { mkpath("$prog->{dir}") };
+		if ( $@ ) {
+			main::logger "ERROR: Could not create dir '$prog->{dir}': $@";
+			exit 1;
+		}
 	}
 }
 
@@ -4273,6 +4289,14 @@ sub download_retry_loop {
 				# quit if successful or skip (unless --multimode selected)
 				last if ( $retcode == 0 || $retcode == 2 ) && ! $opt->{multimode};
 			}
+			if ( $retcode && ! $opt->{multimode} ) {
+				if ( $prog->{type} eq 'radio' || $prog->{type} eq 'liveradio' ) {
+					if ( grep(/wma/, @available_modes) && ! grep(/wma/, @modes) ) {
+						main::logger "INFO: You may wish to try --modes=wma for version $version\n";
+						main::logger "INFO: Note that wma mode is real-time only, and thus is generally only suitable for recording live radio.\n";
+					}
+				}
+			}
 		}
 		# Break out of loop if we have a successful recording for this version and mode
 		return 0 if not $retcode;
@@ -5028,6 +5052,9 @@ sub get_verpids {
 		} elsif ( $xml =~ m{href="http://www.bbc.co.uk/iplayer/episode/(b0[a-z0-9]{6})"} ) {
 			$prog->{pid} = $1;
 			$url = 'http://www.bbc.co.uk/iplayer/playlist/'.$1;
+		# playlist embedded in JSON
+		} elsif ( $xml =~ m{"href":"(http:\\/\\/playlists.bbc.co.uk\\/.+?\\/playlist.sxml)"} ) {
+ 			($url = $1) =~ s/\\//g;
 		} elsif ( $url =~ m{^http.+.xml$} ) {
 			# Just keep the url as it is probably already an xml playlist
 		## playlist: "http://www.bbc.co.uk/iplayer/playlist/bbc_radio_one",
@@ -5207,7 +5234,7 @@ sub get_metadata {
 	my $entry;
 	my $prog_feed_url = 'http://feeds.bbc.co.uk/iplayer/episode/'; # $pid
 
-	my ($name, $episode, $desc, $available, $channel, $expiry, $meddesc, $longdesc, $summary, $versions, $guidance, $prog_type, $categories, $player, $thumbnail, $seriestitle, $episodetitle, $nametitle, $seriesnum, $episodenum );
+	my ($name, $episode, $desc, $available, $channel, $expiry, $meddesc, $longdesc, $summary, $versions, $guidance, $prog_type, $categories, $category, $player, $thumbnail, $seriestitle, $episodetitle, $nametitle, $seriesnum, $episodenum );
 
 	# This URL works for all prog types:
 	# http://www.bbc.co.uk/iplayer/playlist/${pid}
@@ -5341,6 +5368,15 @@ sub get_metadata {
 			push @cats, $1 if m{\s*label="(.+?)">\d+<\/media:category>};
 		}
 		$categories = join ',', @cats;
+		# capture first category, skip generic values
+		my @ignore_categories = ("Films", "Sign Zone", "Audio Described", "Northern Ireland", "Scotland", "Wales", "England");
+		foreach my $cat ( @cats ) {
+			if ( ! grep(/$cat/i,  @ignore_categories) ) {
+				$category = $cat;
+				last
+			}
+		}
+		$category ||= "get_iplayer";
 	}
 
 
@@ -5451,14 +5487,14 @@ sub get_metadata {
 		# Flatten
 		$rdf =~ s|\n| |g;
 		# Get min/max bcast dates from rdf
-		my ( $first, $last, $first_string, $last_string ) = ( 9999999999, 0, 'Never', 'Never' );
+		my ( $now, $first, $last, $first_string, $last_string ) = ( time(), 9999999999, 0, 'Never', 'Never' );
 
 		# <po:(First|Repeat)Broadcast>
 		#  <po:schedule_date rdf:datatype="http://www.w3.org/2001/XMLSchema#date">2009-06-06</po:schedule_date>
 		#    <event:time>
 		#        <timeline:Interval>
 		#              <timeline:start rdf:datatype="http://www.w3.org/2001/XMLSchema#dateTime">2009-06-06T21:30:00+01:00</timeline:start>
-		for ( split /<po:(First|Repeat)Broadcast>/, $rdf ) {
+		for ( split /<po:(First|Repeat)?Broadcast/, $rdf ) {
 			my $timestring;
 			my $epoch;
 			$timestring = $1 if m{<timeline:start\s+rdf:datatype=".+?">(20\d\d-\d\d-\d\dT\d\d:\d\d:\d\d([+-]\d\d:\d\d|Z))<};
@@ -5469,7 +5505,7 @@ sub get_metadata {
 				$first = $epoch;
 				$first_string = $timestring;
 			}
-			if ( $epoch > $last ) {
+			if ( $now > $epoch && $epoch > $last ) {
 				$last = $epoch;
 				$last_string = $timestring;
 			}
@@ -5480,6 +5516,8 @@ sub get_metadata {
 			$prog->{lastbcast}->{$version} = $last_string;
 			$prog->{firstbcastrel}->{$version} = Programme::get_time_string( $first_string, time() );
 			$prog->{lastbcastrel}->{$version} = Programme::get_time_string( $last_string, time() );
+			($prog->{firstbcastdate}->{$version} = $first_string) =~ s/T.*$//;
+			($prog->{lastbcastdate}->{$version} = $last_string) =~ s/T.*$//;
 		}
 	}
 
@@ -5547,6 +5585,7 @@ sub get_metadata {
 	$prog->{versions}	= $versions;
 	$prog->{guidance}	= $guidance || $prog->{guidance};
 	$prog->{categories}	= $categories || $prog->{categories};
+	$prog->{category}	= $category || $prog->{category};
 	$prog->{desc}		= $longdesc || $meddesc || $desc || $prog->{desc} || $summary;
 	$prog->{descmedium}	= $meddesc;
 	$prog->{descshort}	= $summary;
@@ -7080,7 +7119,10 @@ sub download {
 		$subfile_done = "$prog->{dir}/$prog->{fileprefix}.srt";
 		$subfile = "$prog->{dir}/$prog->{fileprefix}.partial.srt";
 		main::logger "\n";
-		$prog->download_subtitles( $ua, $subfile );
+		if ( $prog->download_subtitles( $ua, $subfile ) && $opt->{subsrequired} && $prog->{type} eq 'tv') {
+			main::logger "WARNING: Subtitles not available and --subsrequired specified.\n";
+			return 'skip';
+		}
 	}
 
 	my $return = 0;
@@ -7179,33 +7221,47 @@ sub download_subtitles {
 	#<p begin="0:01:12.400" end="0:01:13.880">Thinking.</p>
 	#<p begin="00:01:01.88" id="p15" end="00:01:04.80"><span tts:color="cyan">You're thinking of Hamburger Hill...<br /></span>Since we left...</p>
 	#<p begin="00:00:18.48" id="p0" end="00:00:20.52">APPLAUSE AND CHEERING</p>
+	# There is also a multiline form:
+	#<p region="speaker" begin="00:00:01.840" end="00:00:08.800"><span style="textStyle">  This programme contains  <br/>
+	#                  some strong language</span></p>
+
 	my $count = 1;
-	my @lines = grep /<p\s.*begin=/, split /\n/, $subs;
-	for ( @lines ) {
-		my ( $begin, $end, $sub );
-		# Remove <br /> elements
-		s|<br.*?>| |g;
-		# Remove >1 spaces
-		s|\s{2,}| |g;
-		( $begin, $end, $sub ) = ( $1, $2, $3 ) if m{<p\s+.*begin="(.+?)".+end="(.+?)".*?>(.+?)<\/p>};
-		if ($begin && $end && $sub ) {
-			# Format numerical field widths
-			$begin = sprintf( '%02d:%02d:%02d,%02d', split /[:\.,]/, $begin );
-			$end = sprintf( '%02d:%02d:%02d,%02d', split /[:\.,]/, $end );
-			# Add trailing zero if ttxt format only uses hundreths of a second
-			$begin .= '0' if $begin =~ m{,\d\d$};
-			$end .= '0' if $end =~ m{,\d\d$};
+	for ( $subs =~ m{<p\b.+?</p>}gis ) {
+		my ( $begin, $end, $sub ) = ( m{\bbegin="(.+?)".*?\bend="(.+?)".*?>(.+?)</p>}is );
+		if ( $begin && $end && $sub ) {
+			($begin = sprintf( '%02d:%02d:%06.3f', split /:/, $begin )) =~ s/\./,/;
+			($end = sprintf( '%02d:%02d:%06.3f', split /:/, $end )) =~ s/\./,/;
 			if ($opt->{suboffset}) {
 				$begin = main::subtitle_offset( $begin, $opt->{suboffset} );
 				$end = main::subtitle_offset( $end, $opt->{suboffset} );
 			}
-			# Separate individual lines based on <span>s
-			$sub =~ s|<span.*?>(.*?)</span>|\n$1\n|g;
+			# remove line breaks, squeeze whitespace, fix up <br> and <span>
+			$sub =~ s|\n+||g;
+			$sub =~ s/(^\s+|\s+$)//g;
+			$sub =~ s|\s+| |g;
+			$sub =~ s|(<br.*?>\s?)+|<br/>|gi;
+			$sub =~ s!(^<br/>|<br/>$)!!g;
+			$sub =~ s|<br/>(</span>)$|$1|i;
+			$sub =~ s|(<span.*?>)\s|$1|i;
+			# separate individual lines based on <span>s
+			$sub =~ s|<span.*?>(.*?)</span>|\n$1\n|gi;
 			if ($sub =~ m{\n}) {
-				chomp($sub);
-				$sub =~ s|^\n?|- |;
+				# fix up line breaks
+				$sub =~ s/(^\n|\n$)//g;
+				# add leading hyphens
 				$sub =~ s|\n+|\n- |g;
+				if ( $sub =~ m{\n-} ) {
+					$sub =~ s|^|- |;
+				}
 			}
+			if ( $opt->{subsfmt} eq 'compact' ) {
+				$sub =~ s|\n+||g;
+				# embed line breaks
+				$sub =~ s|<br/>|\n|g;
+			} else {
+				# remove <br/> elements
+				$sub =~ s|<br/>| |g;
+			}
 			decode_entities($sub);
 			# Write to file
 			print $fh "$count\n";
@@ -7318,9 +7374,6 @@ sub channels_schedule {
 	return {
 		'1xtra/programmes/schedules'		=> 'BBC 1Xtra',
 		'radio1/programmes/schedules/england'	=> 'BBC Radio 1 England',
-		'radio1/programmes/schedules/northernireland'=> 'BBC Radio 1 Northern Ireland',
-		'radio1/programmes/schedules/scotland'	=> 'BBC Radio 1 Scotland',
-		'radio1/programmes/schedules/wales'	=> 'BBC Radio 1 Wales',
 		'radio2/programmes/schedules'		=> 'BBC Radio 2',
 		'radio3/programmes/schedules'		=> 'BBC Radio 3',
 		'radio4/programmes/schedules/fm'	=> 'BBC Radio 4 FM',
@@ -7385,7 +7438,7 @@ sub channels_schedule {
 # Class cmdline Options
 sub opt_format {
 	return {
-		radiomode	=> [ 1, "radiomode|amode=s", 'Recording', '--radiomode <mode>,<mode>,...', "Radio recording modes: flashaachigh,flashaacstd,flashaudio,flashaaclow,wma. Shortcuts: default,good,better(=default),best,rtmp,flash,flashaac. ('default'=flashaachigh,flashaacstd,flashaudio,flashaaclow,wma)"],
+		radiomode	=> [ 1, "radiomode|amode=s", 'Recording', '--radiomode <mode>,<mode>,...', "Radio recording modes: flashaachigh,flashaacstd,flashaudio,flashaaclow,wma. Shortcuts: default,good,better(=default),best,rtmp,flash,flashaac. ('default'=flashaachigh,flashaacstd,flashaudio,flashaaclow)"],
 		bandwidth 	=> [ 1, "bandwidth=n", 'Recording', '--bandwidth', "In radio realaudio mode specify the link bandwidth in bps for rtsp streaming (default 512000)"],
 		lame		=> [ 0, "lame=s", 'External Program', '--lame <path>', "Location of lame binary"],
 		outputradio	=> [ 1, "outputradio=s", 'Output', '--outputradio <dir>', "Output directory for radio recordings"],
@@ -7436,11 +7489,6 @@ sub modelist {
 	if ( ! $mlist ) {
 		if ( ! main::exists_in_path('rtmpdump') ) {
 			main::logger "WARNING: Not using flash modes since rtmpdump is not found\n" if $opt->{verbose};
-			if ( ! main::exists_in_path('mplayer') ) {
-				main::logger "WARNING: Not using wma mode since mplayer is not found\n" if $opt->{verbose};
-			} else {
-				$mlist = 'wma';
-			}
 		} else {
 			$mlist = 'default';
 		}
@@ -7449,7 +7497,7 @@ sub modelist {
 	$mlist = main::expand_list($mlist, 'best', 'default');
 	$mlist = main::expand_list($mlist, 'better', 'default');
 	$mlist = main::expand_list($mlist, 'good', 'default');
-	$mlist = main::expand_list($mlist, 'default', 'flash,wma');
+	$mlist = main::expand_list($mlist, 'default', 'flash');
 	$mlist = main::expand_list($mlist, 'rtmp', 'flash');
 	$mlist = main::expand_list($mlist, 'flash', 'flashaachigh,flashaacstd,flashaudio,flashaaclow');
 	$mlist = main::expand_list($mlist, 'flashaac', 'flashaachigh,flashaacstd,flashaaclow');
@@ -7809,7 +7857,7 @@ sub channels {
 # Class cmdline Options
 sub opt_format {
 	return {
-		liveradiomode	=> [ 1, "liveradiomode=s", 'Recording', '--liveradiomode <mode>,<mode>,..', "Live Radio recording modes: flashaachigh,flashaacstd,flashaudio,flashaaclow,wma. Shortcuts: default,good,better(=default),best,rtmp,flash,flashaac. ('default'=flashaachigh,flashaacstd,flashaaclow,wma)"],
+		liveradiomode	=> [ 1, "liveradiomode=s", 'Recording', '--liveradiomode <mode>,<mode>,..', "Live Radio recording modes: flashaachigh,flashaacstd,flashaudio,flashaaclow,wma. Shortcuts: default,good,better(=default),best,rtmp,flash,flashaac. ('default'=flashaachigh,flashaacstd,flashaaclow)"],
 		outputliveradio	=> [ 1, "outputliveradio=s", 'Output', '--outputliveradio <dir>', "Output directory for live radio recordings"],
 		rtmpliveradioopts => [ 1, "rtmp-liveradio-opts|rtmpliveradioopts=s", 'Recording', '--rtmp-liveradio-opts <options>', "Add custom options to rtmpdump for liveradio"],
 		ffmpegliveradioopts => [ 1, "ffmpeg-liveradio-opts|ffmpegliveradioopts=s", 'Recording', '--ffmpeg-liveradio-opts <options>', "Add custom options to ffmpeg re-muxing for liveradio"],
@@ -7842,11 +7890,6 @@ sub modelist {
 	if ( ! $mlist ) {
 		if ( ! main::exists_in_path('rtmpdump') ) {
 			main::logger "WARNING: Not using flash modes since rtmpdump is not found\n" if $opt->{verbose};
-			if ( ! main::exists_in_path('mplayer') ) {
-				main::logger "WARNING: Not using wma mode since mplayer is not found\n" if $opt->{verbose};
-			} else {
-				$mlist = 'wma';
-			}
 		} else {
 			$mlist = 'default';
 		}
@@ -7855,7 +7898,7 @@ sub modelist {
 	$mlist = main::expand_list($mlist, 'best', 'default');
 	$mlist = main::expand_list($mlist, 'better', 'default');
 	$mlist = main::expand_list($mlist, 'good', 'default');
-	$mlist = main::expand_list($mlist, 'default', 'flash,wma');
+	$mlist = main::expand_list($mlist, 'default', 'flash');
 	$mlist = main::expand_list($mlist, 'rtmp', 'flash');
 	$mlist = main::expand_list($mlist, 'flash', 'flashaachigh,flashaacstd,flashaudio,flashaaclow');
 	$mlist = main::expand_list($mlist, 'flashaac', 'flashaachigh,flashaacstd,flashaaclow');
@@ -9578,12 +9621,7 @@ sub tags_from_metadata {
 	# composer references iPlayer
 	$tags->{composer} = "BBC iPlayer";
 	# extract genre as first category, use second if first too generic
-	my @ignore = ("Films", "Sign Zone", "Audio Described", "Northern Ireland", "Scotland", "Wales", "England");
-	my ($genre, $genre2) = split(/\s*,\s*/, $meta->{categories}, 3);
-	if ( $genre && $genre2 && grep(/$genre/i, @ignore) ) { $genre = $genre2; }
-	# fallback genre
-	$genre ||= "get_iplayer";
-	$tags->{genre} = $genre;
+	$tags->{genre} = $meta->{category};
 	$tags->{comment} = $meta->{descshort};
 	# fix up firstbcast if necessary
 	$tags->{year} = $meta->{firstbcast};
@@ -9686,6 +9724,9 @@ sub tag_file_id3 {
 		main::logger "INFO: ID3 tagging \U$meta->{ext}\E file\n";
 		# translate podcast flag
 		$tags->{podcastFlag} = "\x01";
+		for ( keys %$tags ) {
+			$tags->{$_} = '' if ! defined $tags->{$_};
+		}
 		# remove existing tag(s) to avoid decoding errors
 		my $mp3 = MP3::Tag->new($meta->{filename});
 		$mp3->get_tags();
@@ -9747,7 +9788,7 @@ sub tag_file_id3 {
 # add basic ID3 tag with id3v2
 sub tag_file_id3_basic {
 	my ($self, $meta, $tags) = @_;
-	if ( main::exists_in_path('id3v2') ) {
+	if ( main::exists_in_path('id3tag') ) {
 		main::logger "INFO: ID3 BASIC tagging \U$meta->{ext}\E file\n";
 		# notify about limitations of basic tagging
 		if ( $opt->{verbose} ) {
