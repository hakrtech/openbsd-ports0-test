$OpenBSD: patch-lib_ansible_module_utils_facts_py,v 1.10 2016/11/01 20:43:14 jasper Exp $

- Add OpenBSD virtualization facts
  b4f338bca738cbd3e3b64be2fc9579bcefa28d6e

- Enable VMM detection
  https://github.com/ansible/ansible/pull/18268

- Simplify processor fact resolution
  https://github.com/ansible/ansible/pull/18278

- Implement DMI facts
  88970bcfb24864c5773c8d913c45db3e7355a74d

- Swap distribution_version and distribution_release values
  https://github.com/ansible/ansible/pull/18277

--- lib/ansible/module_utils/facts.py.orig	Thu Sep 29 17:01:13 2016
+++ lib/ansible/module_utils/facts.py	Mon Oct 31 18:47:55 2016
@@ -344,13 +344,13 @@ class Facts(object):
             self.facts['distribution_version'] = platform.version()
         elif self.facts['system'] == 'OpenBSD':
             self.facts['distribution'] = 'OpenBSD'
-            self.facts['distribution_release'] = platform.release()
+            self.facts['distribution_version'] = platform.release()
             rc, out, err = self.module.run_command("/sbin/sysctl -n kern.version")
             match = re.match('OpenBSD\s[0-9]+.[0-9]+-(\S+)\s.*', out)
             if match:
-                self.facts['distribution_version'] = match.groups()[0]
+                self.facts['distribution_release'] = match.groups()[0]
             else:
-                self.facts['distribution_version'] = 'release'
+                self.facts['distribution_release'] = 'release'
         else:
             dist = platform.dist()
             self.facts['distribution'] = dist[0].capitalize() or 'NA'
@@ -1408,10 +1408,10 @@ class OpenBSDHardware(Hardware):
     - processor_cores
     - processor_count
     - processor_speed
-    - devices
+
+    In addition, it also defines number of DMI facts and device facts.
     """
     platform = 'OpenBSD'
-    DMESG_BOOT = '/var/run/dmesg.boot'
 
     def populate(self):
         self.sysctl = self.get_sysctl()
@@ -1419,6 +1419,7 @@ class OpenBSDHardware(Hardware):
         self.get_processor_facts()
         self.get_device_facts()
         self.get_mount_facts()
+        self.get_dmi_facts()
         return self.facts
 
     def get_sysctl(self):
@@ -1469,25 +1470,43 @@ class OpenBSDHardware(Hardware):
 
     def get_processor_facts(self):
         processor = []
-        dmesg_boot = get_file_content(OpenBSDHardware.DMESG_BOOT)
-        if not dmesg_boot:
-            rc, dmesg_boot, err = self.module.run_command("/sbin/dmesg")
-        i = 0
-        for line in dmesg_boot.splitlines():
-            if line.split(' ', 1)[0] == 'cpu%i:' % i:
-                processor.append(line.split(' ', 1)[1])
-                i = i + 1
-        processor_count = i
+        for i in range(int(self.sysctl['hw.ncpu'])):
+            processor.append(self.sysctl['hw.model'])
+
         self.facts['processor'] = processor
-        self.facts['processor_count'] = processor_count
-        # I found no way to figure out the number of Cores per CPU in OpenBSD
-        self.facts['processor_cores'] = 'NA'
+        # The following is partly a lie because there is no reliable way to
+        # determine the number of physical CPUs in the system. We can only
+        # query the number of logical CPUs, which hides the number of cores.
+        # On amd64/i386 we could try to inspect the smt/core/package lines in
+        # dmesg, however even those have proven to be unreliable.
+        # So take a shortcut and report the logical number of processors in
+        # 'processor_count' and leave it at that.
+        self.facts['processor_count'] = self.sysctl['hw.ncpu']
 
     def get_device_facts(self):
         devices = []
         devices.extend(self.sysctl['hw.disknames'].split(','))
         self.facts['devices'] = devices
 
+    def get_dmi_facts(self):
+        # We don't use dmidecode(1) here because:
+        # - it would add dependency on an external package
+        # - dmidecode(1) can only be ran as root
+        # So instead we rely on sysctl(8) to provide us the information on a
+        # best-effort basis. As a bonus we also get facts on non-amd64/i386
+        # platforms this way.
+        sysctl_to_dmi = {
+            'hw.product':  'product_name',
+            'hw.version':  'product_version',
+            'hw.uuid':     'product_uuid',
+            'hw.serialno': 'product_serial',
+            'hw.vendor':   'system_vendor',
+        }
+
+        for mib in sysctl_to_dmi:
+            if mib in self.sysctl:
+                self.facts[sysctl_to_dmi[mib]] = self.sysctl[mib]
+
 class FreeBSDHardware(Hardware):
     """
     FreeBSD-specific subclass of Hardware.  Defines memory and CPU facts:
@@ -2926,14 +2945,59 @@ class OpenBSDVirtual(Virtual):
     - virtualization_role
     """
     platform = 'OpenBSD'
+    DMESG_BOOT = '/var/run/dmesg.boot'
 
     def populate(self):
         self.get_virtual_facts()
         return self.facts
 
     def get_virtual_facts(self):
+        sysctl_path = self.module.get_bin_path('sysctl')
+
+        # Set empty values as default
         self.facts['virtualization_type'] = ''
         self.facts['virtualization_role'] = ''
+
+        if sysctl_path:
+            rc, out, err = self.module.run_command("%s -n hw.product" % sysctl_path)
+            if rc == 0:
+                if re.match('(KVM|Bochs|SmartDC).*', out):
+                    self.facts['virtualization_type'] = 'kvm'
+                    self.facts['virtualization_role'] = 'guest'
+                elif re.match('.*VMware.*', out):
+                    self.facts['virtualization_type'] = 'VMware'
+                    self.facts['virtualization_role'] = 'guest'
+                elif out.rstrip() == 'VirtualBox':
+                    self.facts['virtualization_type'] = 'virtualbox'
+                    self.facts['virtualization_role'] = 'guest'
+                elif out.rstrip() == 'HVM domU':
+                    self.facts['virtualization_type'] = 'xen'
+                    self.facts['virtualization_role'] = 'guest'
+                elif out.rstrip() == 'Parallels':
+                    self.facts['virtualization_type'] = 'parallels'
+                    self.facts['virtualization_role'] = 'guest'
+                elif out.rstrip() == 'RHEV Hypervisor':
+                    self.facts['virtualization_type'] = 'RHEV'
+                    self.facts['virtualization_role'] = 'guest'
+                else:
+                    # Try harder and see if hw.vendor has anything we could use.
+                    rc, out, err = self.module.run_command("%s -n hw.vendor" % sysctl_path)
+                    if rc == 0:
+                        if out.rstrip() == 'QEMU':
+                            self.facts['virtualization_type'] = 'kvm'
+                            self.facts['virtualization_role'] = 'guest'
+                        if out.rstrip() == 'OpenBSD':
+                            self.facts['virtualization_type'] = 'vmm'
+                            self.facts['virtualization_role'] = 'guest'
+
+        # Check the dmesg if vmm(4) attached, indicating the host is
+        # capable of virtualization.
+        dmesg_boot = get_file_content(OpenBSDVirtual.DMESG_BOOT)
+        for line in dmesg_boot.splitlines():
+            match = re.match('^vmm0 at mainbus0: (SVM/RVI|VMX/EPT)$', line)
+            if match:
+                self.facts['virtualization_type'] = 'vmm'
+                self.facts['virtualization_role'] = 'host'
 
 class HPUXVirtual(Virtual):
     """
