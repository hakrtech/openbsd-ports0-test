$OpenBSD: patch-eject_eject_c,v 1.1 2015/10/26 19:44:06 zhuk Exp $
Unbreak after d_un removal in sys/disklabel.h.
--- eject/eject.c.orig	Mon Oct 26 20:38:40 2015
+++ eject/eject.c	Mon Oct 26 20:42:06 2015
@@ -186,6 +186,12 @@ inq2names(struct dk_inquiry *inq, char *name, size_t s
 	strlcat(name, inq->product, sz);
 }
 
+#ifdef __OpenBSD__
+# define dpackname d_packname
+#else
+# define dpackname d_un.un_d_packname
+#endif
+
 /*
  * disklabel's d_typename and d_un.un_d_packname each is 16 bytes long.
  * name is 192 bytes long. So, we don't need complex boundary checking.
@@ -197,12 +203,12 @@ disklabel2names(struct disklabel *dl, char *name)
 	size_t i, k;
 
 	k = 0;
-	for (i = 0; i < sizeof(dl->d_un.un_d_packname); i++)
-		if (!isspace(dl->d_un.un_d_packname[i]))
+	for (i = 0; i < sizeof(dl->dpackname); i++)
+		if (!isspace(dl->dpackname[i]))
 			break;
-	if (i < sizeof(dl->d_un.un_d_packname)) {
-		k = sizeof(dl->d_un.un_d_packname) - i;
-		memcpy(name, dl->d_un.un_d_packname + i, k);
+	if (i < sizeof(dl->dpackname)) {
+		k = sizeof(dl->dpackname) - i;
+		memcpy(name, dl->dpackname + i, k);
 		for (i = k; i > 0; i--) {
 			if (!isspace(name[i - 1]) && name[i - 1] != '\0')
 				break;
@@ -232,6 +238,8 @@ disklabel2names(struct disklabel *dl, char *name)
 	if (*name == '\0')
 		memcpy(name, "NONAME", 7);
 }
+
+#undef dpackname
 
 static void
 notify_ejected(const char *label, const char *devname)
