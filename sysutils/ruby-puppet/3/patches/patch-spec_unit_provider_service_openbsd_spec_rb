$OpenBSD: patch-spec_unit_provider_service_openbsd_spec_rb,v 1.1 2013/09/17 09:00:58 jasper Exp $
--- spec/unit/provider/service/openbsd_spec.rb.orig	Tue Sep 17 10:59:45 2013
+++ spec/unit/provider/service/openbsd_spec.rb	Tue Sep 17 10:59:56 2013
@@ -0,0 +1,130 @@
+#!/usr/bin/env ruby
+#
+# Unit testing for the OpenBSD service provider
+
+require 'spec_helper'
+
+provider_class = Puppet::Type.type(:service).provider(:openbsd)
+
+describe provider_class do
+#  before :each do
+#    @resource = stub 'resource'
+#    @provider = provider_class.new
+
+    # Catch all; no parameters set
+#    @resource.stubs(:[]).returns(nil)
+
+    # Do set name and ensure
+#    @resource.stubs(:[]).with(:name).returns "myservice"
+#    @resource.stubs(:[]).with(:ensure).returns "running"
+#    @resource.stubs(:ref).returns "Service[myservice]"
+
+#    @provider.resource = @resource
+#  end
+
+  let :rcscripts do
+    [
+     'apmd',
+     'aucat',
+     'cron',
+     'puppetd'
+   ]
+  end
+
+  describe "#instances" do
+    it "should have an instances method" do
+      described_class.should respond_to :instances
+    end
+
+    it "should list all available services" do
+      Dir.expects(:entries).with('/etc/rc.d').returns rcscripts
+
+      rcscripts.each do |script|
+        FileTest.expects(:executable?).with("/etc/rc.d/#{script}").returns true
+      end
+
+      described_class.instances.map(&:name).should == [
+        'apmd',
+        'aucat',
+        'cron',
+        'puppetd'
+      ]
+    end
+  end
+
+  describe "#start" do
+    it "should use the supplied start command if specified" do
+      provider = described_class.new(Puppet::Type.type(:service).new(:name => 'sshd', :start => '/bin/foo'))
+      provider.expects(:execute).with(['/bin/foo'], :failonfail => true, :squelch => true)
+      provider.start
+    end
+
+    it "should start the service otherwise" do
+      provider = described_class.new(Puppet::Type.type(:service).new(:name => 'sshd'))
+      provider.expects(:execute).with(['/etc/rc.d/sshd', '-f', :start], :failonfail => true, :squelch => true)
+      provider.start
+    end
+  end
+
+  describe "#stop" do
+    it "should use the supplied stop command if specified" do
+      provider = described_class.new(Puppet::Type.type(:service).new(:name => 'sshd', :stop => '/bin/foo'))
+      provider.expects(:execute).with(['/bin/foo'], :failonfail => true, :squelch => true)
+      provider.stop
+    end
+
+    it "should stop the service otherwise" do
+      provider = described_class.new(Puppet::Type.type(:service).new(:name => 'sshd'))
+      provider.expects(:execute).with(['/etc/rc.d/sshd', :stop], :failonfail => true, :squelch => true)
+      provider.stop
+    end
+  end
+
+  describe "#status" do
+    it "should use the status command from the resource" do
+      provider = described_class.new(Puppet::Type.type(:service).new(:name => 'sshd', :status => '/bin/foo'))
+      provider.expects(:execute).with(['/etc/rc.d/sshd', :status], :failonfail => false, :squelch => true).never
+      provider.expects(:execute).with(['/bin/foo'], :failonfail => false, :squelch => true)
+      provider.status
+    end
+
+      it "should return :stopped when status command returns with a non-zero exitcode" do
+        provider = described_class.new(Puppet::Type.type(:service).new(:name => 'sshd', :status => '/bin/foo'))
+        provider.expects(:execute).with(['/etc/rc.d/sshd', :status], :failonfail => false, :squelch => true).never
+        provider.expects(:execute).with(['/bin/foo'], :failonfail => false, :squelch => true)
+        $CHILD_STATUS.stubs(:exitstatus).returns 3
+        provider.status.should == :stopped
+      end
+
+      it "should return :running when status command returns with a zero exitcode" do
+        provider = described_class.new(Puppet::Type.type(:service).new(:name => 'sshd', :status => '/bin/foo'))
+        provider.expects(:execute).with(['/etc/rc.d/sshd', :status], :failonfail => false, :squelch => true).never
+        provider.expects(:execute).with(['/bin/foo'], :failonfail => false, :squelch => true)
+        $CHILD_STATUS.stubs(:exitstatus).returns 0
+        provider.status.should == :running
+      end
+  end
+
+  describe "#restart" do
+    it "should use the supplied restart command if specified" do
+      provider = described_class.new(Puppet::Type.type(:service).new(:name => 'sshd', :restart => '/bin/foo'))
+      provider.expects(:execute).with(['/etc/rc.d/sshd', '-f', :restart], :failonfail => true, :squelch => true).never
+      provider.expects(:execute).with(['/bin/foo'], :failonfail => true, :squelch => true)
+      provider.restart
+    end
+
+    it "should restart the service with rc-service restart if hasrestart is true" do
+      provider = described_class.new(Puppet::Type.type(:service).new(:name => 'sshd', :hasrestart => true))
+      provider.expects(:execute).with(['/etc/rc.d/sshd', '-f', :restart], :failonfail => true, :squelch => true)
+      provider.restart
+    end
+
+    it "should restart the service with rc-service stop/start if hasrestart is false" do
+      provider = described_class.new(Puppet::Type.type(:service).new(:name => 'sshd', :hasrestart => false))
+      provider.expects(:execute).with(['/etc/rc.d/sshd', '-f', :restart], :failonfail => true, :squelch => true).never
+      provider.expects(:execute).with(['/etc/rc.d/sshd', :stop], :failonfail => true, :squelch => true)
+      provider.expects(:execute).with(['/etc/rc.d/sshd', '-f', :start], :failonfail => true, :squelch => true)
+      provider.restart
+    end
+  end
+end
