$OpenBSD: patch-daemon_gvfschannel_c,v 1.1 2013/04/05 14:07:31 ajacoutot Exp $

From a376e0808c2e8212462025d8065e60d091995d36 Mon Sep 17 00:00:00 2001
From: Tomas Bzatek <tbzatek@redhat.com>
Date: Wed, 03 Apr 2013 13:08:20 +0000
Subject: gvfschannel: Return proper error if we're out of free fds

From d667f6fe956d8661710f9fe5ad3e54d9b24aa04a Mon Sep 17 00:00:00 2001
From: Alexander Larsson <alexl@redhat.com>
Date: Thu, 04 Apr 2013 08:25:29 +0000
Subject: Fix daemon crash when cancelling channel operations

From 6141549ed4660e888fb6438434c789db47b6f665 Mon Sep 17 00:00:00 2001
From: Alexander Larsson <alexl@redhat.com>
Date: Thu, 04 Apr 2013 17:08:02 +0000
Subject: channel: Unqueue cancelled requests

--- daemon/gvfschannel.c.orig	Fri Apr  5 15:52:20 2013
+++ daemon/gvfschannel.c	Fri Apr  5 15:50:45 2013
@@ -40,6 +40,7 @@
 #include <gvfsdaemonutils.h>
 #include <gvfsjobcloseread.h>
 #include <gvfsjobclosewrite.h>
+#include <gvfsjoberror.h>
 #include <gvfsfileinfo.h>
 
 static void g_vfs_channel_job_source_iface_init (GVfsJobSourceIface *iface);
@@ -200,7 +201,7 @@ g_vfs_channel_init (GVfsChannel *channel)
 
   ret = socketpair (AF_UNIX, SOCK_STREAM, 0, socket_fds);
   if (ret == -1) 
-    g_warning ("Error creating socket pair: %d\n", errno);
+    g_warning ("Error creating socket pair: %s\n", g_strerror (errno));
   else
     {
       channel->priv->command_stream = g_unix_input_stream_new (socket_fds[0], TRUE);
@@ -312,39 +313,36 @@ start_queued_request (GVfsChannel *channel)
       channel->priv->queued_requests =
 	g_list_delete_link (channel->priv->queued_requests,
 			    channel->priv->queued_requests);
-      
+
       error = NULL;
-      job = NULL;
-      if (req->cancelled)
+      /* This passes on ownership of req->data */
+      job = class->handle_request (channel,
+				   req->command, req->seq_nr,
+				   req->arg1, req->arg2,
+				   req->data, req->data_len,
+				   &error);
+
+      if (job != NULL && req->cancelled)
 	{
-	  error =
-	    g_error_new_literal (G_IO_ERROR, G_IO_ERROR_CANCELLED,
-				 _("Operation was cancelled"));
-	  g_free (req->data); /* Did no pass ownership */
+	  /* Ignore the job, although we need to create it to rely
+	     on handle_request side effects like seek generations, etc */
+	  g_object_unref (job);
+	  job = NULL;
+	  error =  g_error_new_literal (G_IO_ERROR, G_IO_ERROR_CANCELLED,
+					_("Operation was cancelled"));
 	}
-      else
+
+      if (job == NULL)
 	{
-	  /* This passes on ownership of req->data */
-	  job = class->handle_request (channel,
-				       req->command, req->seq_nr,
-				       req->arg1, req->arg2,
-				       req->data, req->data_len, 
-				       &error);
-	}
-      
-      if (job)
-	{
-	  channel->priv->current_job = job;
-	  channel->priv->current_job_seq_nr = req->seq_nr;
-	  g_vfs_job_source_new_job (G_VFS_JOB_SOURCE (channel), channel->priv->current_job);
-	  started_job = TRUE;
-	}
-      else
-	{
-	  g_vfs_channel_send_error (channel, error);
+	  job = g_vfs_job_error_new (channel, error);
 	  g_error_free (error);
 	}
-      
+
+      channel->priv->current_job = job;
+      channel->priv->current_job_seq_nr = req->seq_nr;
+      g_vfs_job_source_new_job (G_VFS_JOB_SOURCE (channel), channel->priv->current_job);
+      started_job = TRUE;
+
       g_free (req);
     }
 
