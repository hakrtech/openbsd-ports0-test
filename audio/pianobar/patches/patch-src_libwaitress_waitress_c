$OpenBSD: patch-src_libwaitress_waitress_c,v 1.5 2013/09/02 11:58:40 dcoppa Exp $

waitress: try all addresses returned by getaddrinfo.
Fix connection failures on mixed IPv4/IPv6 systems.
(upstream git commit f1ddd582ba5c314202fbed98d7aa491b06b2dee2)

--- src/libwaitress/waitress.c.orig	Sun May 19 12:58:18 2013
+++ src/libwaitress/waitress.c	Mon Sep  2 11:28:34 2013
@@ -770,8 +770,8 @@ static WaitressReturn_t WaitressTlsVerify (const Waitr
 /*	Connect to server
  */
 static WaitressReturn_t WaitressConnect (WaitressHandle_t *waith) {
-	struct addrinfo hints, *res;
-	int pollres;
+	WaitressReturn_t ret;
+	struct addrinfo hints, *gares;
 
 	memset (&hints, 0, sizeof hints);
 
@@ -781,47 +781,66 @@ static WaitressReturn_t WaitressConnect (WaitressHandl
 	/* Use proxy? */
 	if (WaitressProxyEnabled (waith)) {
 		if (getaddrinfo (waith->proxy.host,
-				WaitressDefaultPort (&waith->proxy), &hints, &res) != 0) {
+				WaitressDefaultPort (&waith->proxy), &hints, &gares) != 0) {
 			return WAITRESS_RET_GETADDR_ERR;
 		}
 	} else {
 		if (getaddrinfo (waith->url.host,
-				WaitressDefaultPort (&waith->url), &hints, &res) != 0) {
+				WaitressDefaultPort (&waith->url), &hints, &gares) != 0) {
 			return WAITRESS_RET_GETADDR_ERR;
 		}
 	}
 
-	if ((waith->request.sockfd = socket (res->ai_family, res->ai_socktype,
-			res->ai_protocol)) == -1) {
-		freeaddrinfo (res);
-		return WAITRESS_RET_SOCK_ERR;
-	}
+	/* try all addresses */
+	for (struct addrinfo *gacurr = gares; gacurr != NULL;
+			gacurr = gacurr->ai_next) {
+		int sock = -1;
 
-	/* we need shorter timeouts for connect() */
-	fcntl (waith->request.sockfd, F_SETFL, O_NONBLOCK);
+		ret = WAITRESS_RET_OK;
 
-	/* increase socket receive buffer */
-	const int sockopt = 256*1024;
-	setsockopt (waith->request.sockfd, SOL_SOCKET, SO_RCVBUF, &sockopt,
-			sizeof (sockopt));
+		if ((sock = socket (gacurr->ai_family, gacurr->ai_socktype,
+				gacurr->ai_protocol)) == -1) {
+			ret = WAITRESS_RET_SOCK_ERR;
+		} else {
+			int pollres;
 
-	/* non-blocking connect will return immediately */
-	connect (waith->request.sockfd, res->ai_addr, res->ai_addrlen);
+			/* we need shorter timeouts for connect() */
+			fcntl (sock, F_SETFL, O_NONBLOCK);
 
-	pollres = WaitressPollLoop (waith->request.sockfd, POLLOUT,
-			waith->timeout);
-	freeaddrinfo (res);
-	if (pollres == 0) {
-		return WAITRESS_RET_TIMEOUT;
-	} else if (pollres == -1) {
-		return WAITRESS_RET_ERR;
+			/* increase socket receive buffer */
+			const int sockopt = 256*1024;
+			setsockopt (sock, SOL_SOCKET, SO_RCVBUF, &sockopt,
+					sizeof (sockopt));
+
+			/* non-blocking connect will return immediately */
+			connect (sock, gacurr->ai_addr, gacurr->ai_addrlen);
+
+			pollres = WaitressPollLoop (sock, POLLOUT, waith->timeout);
+			if (pollres == 0) {
+				ret = WAITRESS_RET_TIMEOUT;
+			} else if (pollres == -1) {
+				ret = WAITRESS_RET_ERR;
+			} else {
+				/* check connect () return value */
+				socklen_t pollresSize = sizeof (pollres);
+				getsockopt (sock, SOL_SOCKET, SO_ERROR, &pollres,
+						&pollresSize);
+				if (pollres != 0) {
+					ret = WAITRESS_RET_CONNECT_REFUSED;
+				} else {
+					/* this one is working */
+					waith->request.sockfd = sock;
+					break;
+				}
+			}
+			close (sock);
+		}
 	}
-	/* check connect () return value */
-	socklen_t pollresSize = sizeof (pollres);
-	getsockopt (waith->request.sockfd, SOL_SOCKET, SO_ERROR, &pollres,
-			&pollresSize);
-	if (pollres != 0) {
-		return WAITRESS_RET_CONNECT_REFUSED;
+
+	freeaddrinfo (gares);
+	/* could not connect to any of the addresses */
+	if (ret != WAITRESS_RET_OK) {
+		return ret;
 	}
 
 	if (waith->url.tls) {
